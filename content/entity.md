### 1. **간접 참조를 통한 애그리거트 간 상호작용**

애그리거트를 설계할 때 직접 참조보다는 간접참조를 활용하여 애그리거트 간 상호작용을 구현했습니다. 이를 통해 애그리거트 간 결합도를 낮추고, 각 애그리거트의 변경이 다른 애그리거트로 전파되는 문제를 방지하고자 했습니다.

- **변경 가능성 증가**: 상품 애그리거트의 변경 사항이 주문 애그리거트로 전파될 가능성이 높아짐.
- **복잡성 증가**: 애그리거트 간의 강한 결합으로 인해 단일 책임 원칙(SRP)을 위배하게 됨.
- **성능 문제**: 직접 매핑으로 인해 불필요한 연관 데이터 로드가 발생하며, 특히 N+1 문제를 초래할 수 있음.


---

### 2. **비즈니스 로직의 위치와 도메인 모델의 역할**

애그리거트 간 간접 참조를 사용하면서 비즈니스 로직을 어디에 작성해야 할지 모호했습니다.

다양한 개념들(도메인 서비스, VO 등)을 학습하며 고민했지만, 명확한 답을 찾지 못했습니다. 그러던 중, 제가 직면한 문제는 **도메인 모델과 영속성 엔티티를 구분하지 않고 사용한 점**에서 비롯된다는 사실을 깨닫게 되었습니다.

- **영속성 엔티티의 문제점**:

  영속성 엔티티는 데이터베이스와의 연동을 주 목적으로 하며, ID 값을 통해 다른 애그리거트와의 간접 참조를 유지했습니다. 하지만 이 상태에서 비즈니스 로직을 작성하려 하니, 로직의 위치가 모호해지고 객체 책임이 분산되는 문제가 발생했습니다.

- **정보 전문가로서의 도메인 모델**:

  비즈니스 로직을 담당하는 객체를 분리하다 보니, 해당 객체는 비즈니스 로직을 수행하기 위해 필요한 모든 정보를 소유하고 있었습니다. 곰곰이 생각해 보니, 이 객체가 바로 도메인 모델이라는 것을 알게 되었습니다.

  즉, 도메인 모델은 비즈니스 규칙을 중심으로 설계되어야 하며, 영속성 엔티티는 데이터의 저장/조회에만 집중하는 별개의 개념이어야 합니다.


결국, 도메인 모델과 영속성 엔티티의 역할을 명확히 분리함으로써, 각자의 책임을 명확히 하고 애그리거트 간 간접 참조를 효율적으로 사용할 수 있게 되었습니다.