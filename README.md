# 서비스 소개

# Glint
https://glint.swygbro.com/

# Repository
https://github.com/G1int/Glint_BE



**'소개팅 앱은 있는데 왜 미팅 앱은 없는 거지?'**

라는 단순한 아이디어에서 시작된 저희 서비스 ✨**Glint**✨는 2030 싱글남녀를 타깃으로

자신과 비슷한 직군, 업계, 학교 등과 미팅을 할 수 있도록 연결해 주는 서비스입니다.


![img.png](/images/img.png)



| 🌟 LOGIN                                          | **랜딩페이지 / 소셜(카카오) 로그인** |
|---------------------------------------------------| --- |
| 🌟 SIGNUP                                         | **회원가입** |
| 🌟 MAIN                                           | **새로 생긴 미팅방 조회**구현 중: 미팅 검색 필터 / 알람 기능 |
| 🌟 CREATE ROOM                                    | **미팅 방 생성**구현 중 : 회사/학교 검색하여 등록 |
| 🌟 MY MEETING                                     | **참가, 대기 미팅 조회 탭** |
| 🌟 MEETING                                        | **미팅 정보를 확인하고 참가 신청을 할 수 있는 홈 탭**구현 중: 채팅 방 공유하기 |
| 🌟 SEARCH                                         | 인기 검색어 / 최근 검색어 / 키워드 검색 시 해당되는 **미팅방 검색**구현 중: 미팅 키워드 필터 |
| 🌟 MY INFO                                        | **내 정보 수정 및 조회**구현 중: 인증 관리 페이지 이동 / 친구 관리 페이지 이동 / 같은 학교, 직장 차단, 연락처로 지인 차단, 채팅 알림 사용, 초대 알림 사용, 참가 신청 알림 사용 |
| 🌟 MY PROFILE                       | 지역, 키, 종교, 흡연, 음주 및 **자기소개 작성**구현 중: 회사/학교 인증 |



# 프로젝트 관련

### 백엔드 개발 목표 및 지향점

1. 도메인 중심의 설계와 개발
    - 도메인 정의, 분석 모델링
    - 데이터 변경의 단위(트랜잭션)으로 연관 객체들을 정의하고 이를 바탕으로 테이블을 설계
2. JPA 의 직접참조 지양 간접참조 지향
    1. 직접참조할 경우 N+1문제나 여러 Entity의 FetchJoin 불가 연관 엔티티 변경 가능성 등 관리 포인트 증가
    2. id를 통한 간접참조를 활용하여 결합도를 낮추자
3. 도메인 모델 패턴 사용
    - 각각 도메인 객체가  ***Information Expert*** 가 될수 있도록 구성
    - 도메인 엔티티 내부에  비즈니스 로직을 응집화 재사용성 향상, 로직 파악 용이하도록 구성.
4. 깨끗한 코드 지향
    1. 객체지향 생활 체조 9가지 원칙
    2. 불변객체 
    3. 일급 클래스
    4. 정적 팩토리 메서드 사용
    5. setter 금지

![img.png](/images/img_1.png)



### 시스템 아키텍처

![img.png](/images/img_2.png)

- Route53 DNS서버 요청을 받아 ALB를 통해 내부 ec2로 라우팅 nginx 리버스 프록시를 통해 최종 서버로 요청될 수 있도록 구성
- Parameter Store를 통핸 환경변수 관리
- RDS (mysql) 저장소 사용
- ElastiCache(redis) 캐싱, Token 저장소 활용
- S3 정적파일 관리(이미지 저장)
- MQ (채팅 프로토콜의 외부브로커)

**배포 자동화 (CI/CD)**

github의 프로젝트를 pull 받아 build 이후 도커 이미지화 하여 배포되도록 구성하였고
jenkins + github 통해 release 브랜치 merge event 발생시 배포되도록 자동화 하였습니다.</br>
이슈에 대해 발빠르게 대응하여 개발의 효율을 높혔습니다.

**nginx를 활용한  리버스 프록시, 로드밸런싱, 무중단 배포**

- nginx를 reverse proxy로 사용하여 로드밸런싱, 무중단 배포 환경을 구성하였습니다.


### 주요 기능

**미팅**

- **미팅 참가신청 수락 및 거절**: 사용자가 미팅에 신청하면, 주최자가 이를 수락하거나 거절할 수 있도록 하였습니다.


- **미팅 조건 유효성 검사**: 미팅 신청 시, 조건에 맞는지 유효성을 검사합니다.


- **내 미팅**: 사용자가 자신이 주최하거나 참가하는 미팅을 조회할 수 있습니다.


- **No-offset 방식 페이징**: 페이징 처리 시 성능을 고려하여 No-offset 방식을 사용하였습니다.

**채팅 기능**

- **STOMP**: 초기에는 인메모리 기반으로 시작하여 외부 브로커를 사용하도록 확장했습니다. 이를 통해 안정성과 확장성을 확보할 수 있었습니다.

**인증/인가**

- Spring Security와 JWT를 사용하여 인증 및 인가를 처리하였습니다.
- **Token 탈취를 고려한 RTR 방식**을 적용하여 AccessToken과 RefreshToken을 관리하였습니다.


**검색 기능**

- QueryDSL을 사용하여 동적 쿼리를 구현하였습니다.

**이미지 업로드**

- 병렬 처리를 통해 이미지 업로드 성능을 최적화하였습니다.

**인덱싱**

- 데이터가 5만개로 가장 많은 university 테이블의 대학 이름에 인덱싱을 걸어 데이터 조회 성능을 향상시켰습니다.
- 또한 자주 변하지 않고 한번 조회될 때 많은 데이터를 불러오기 때문에 **캐싱**하여 조회 시간을 감소시켰습니다.




# 고민 및 이슈


#### 닉네임 선점 (중복검사를 수행하고 가입 버튼을 눌렀는데 중복되었다고?)

- 회원가입 시 닉네임 중복검사와 실제 저장 사이의 시간차로 인해 닉네임 충돌 및 선점 문제가 발생했습니다
- Redis와 만료(expire) 기능을 활용한 방식을 도입했습니다.
- 중복검사 후, nickname:userId 형식으로 Redis에 저장하고, 20분의 만료 시간을 설정하여 중도 이탈 시 닉네임이 자동 반환되도록 했습니다.
- 최종 처리: 가입 완료 시 Redis 키를 제거하여 닉네임을 확정적으로 할당했습니다. 이를 통해 닉네임 충돌, 잘못된 중복 표시, 중도 이탈 문제를 효과적으로 해결했습니다.

<details>
<summary>자세히</summary>

[닉네임 선점](content%2Fnickname.md)

</details>


#### 애그리거트 단위에 대한 고민

- 애그리거트 경계를 설정할 때 생명 주기와 생성 시점만으로 경계를 설정하였습니다.
- 예를 들어, User, UserDetail, UserProfile 각각의 생성 시점이 달라 독립적으로 설계했지만, 삭제 시의 종속성과 데이터 조회/일관성 유지에서 복잡성 증가 문제가 발생했습니다.
- 애그리거트는 소멸 시 종속성과 비즈니스 로직의 요구사항까지 고려하여 설계해야 하며, 생성 시점이 다르더라도 논리적으로 연관된 객체를 하나의 애그리거트로 정의 할 수 있다는 사실을 깨달았습니다. 

<details>
<summary>자세히</summary>

[애그리거트 단위에 대한 고민](content%2Faggregate.md)

</details>

#### 애그리거트간 간접참조 (이것이 도메인 모델인가 영속성 엔티티인가?)

- 도메인 엔티티와 영속성 엔티티를 따로 구분하지 않은 상태로 도메인 모델을 설계하였습니다. 
- 이때 서로 연관성 있는 애그리거트간 참조방식으로 pk를 이용한 간접참조 방식으로 사용하였습니다 
- 영속성 엔티티와 도메인 모델의 구분 없이 설계했기 때문에 비즈니스 로직의 위치가 모호해졌고 비즈니로직을 부여하기 위한 추가적인 객체의 필요성이 생겨났습니다.
- 이를통해 무조건적인 간접참조는 옳지 않다는 것을 깨달았고 간접 참조를 한다면 비즈니스 로직을 수행할 수 있는 정보 전문가 역할의 도메인 모델을 분리하여 책임을 명확히 하는것이 효율적일 것이다 라는 점을 깨닫게 되었습니다.

<details>
<summary>자세히</summary>

[애그리거트간 간접참조](content%2Fentity.md)

</details>


#### 간접 참조와 서비스 계층, UseCase 계층 도입

- 간접 참조를 사용하다 보니, 여러 서비스를 **조합해야 하는 상황**이 많아졌습니다.
- 이로 인해 서비스가 점점 **비대해지**면서, **순환 참조**와 같은 이슈가 발생하고, 서비스의 **역할이 모호해지**는 상황이 일어났습니다.
- Facede 패턴을 도입하여 관리하려했지만 복잡성은 여전히 존재했습니다.
- UseCase계층 도입하였습니다. Service계층에서 전달받은 Entity들을 UseCase에 따라서 호출하여 조합하는 역할을 하도록 구성했습니다
- 이로 인해 서비스가 수행해야 할 역할이 명확해지고, 각 계층이 담당하는 책임도 분명해졌습니다.

<details>
<summary>자세히</summary>

[간접 참조와 서비스 계층, UseCase 계층 도입](content%2Fusecase_layer.md)

</details>


#### 검증로직 이럴떄는 전략패턴이지 

- 회원 가입 시 사용자가 입력하는 다양한 프로필 정보나 미팅에 참가 시 선택된 조건에 대해 검증을 해야 합니다. 
- 한 군데에서 관리하기보다는 전략 패턴을 사용하여 각 조건을 개별적으로 처리하고, 조건의 추가 및 삭제가 용이하도록 설계하였습니다.
- 검증 로직이 클래스별로 분리되어 있기 때문에 수정이 용이하고, 특정 조건만을 독립적으로 수정할 수 있습니다.

<details>
<summary>자세히</summary>

[검증로직 이럴떄는 전략패턴이지](content%2Fstrategy.md)

</details>


#### 테스트 로직 작성 경험 후기: 런던파와 고전파 비교

- 현재 회사에서는 런던파 형식으로 Mock을 적극적으로 사용하는 테스트코드 작성 방식을 사용하고 있습니다.
- 이번 사이드 프로젝트에서 고전파 방식을 사용하면서 각각의 테스트 방식을 장단점을 느꼈고 이를 비교하였습니다.
- Mock을 적극적으로 사용하면 테스트 작성이 빠르고 환경 제어가 용이하지만, 실제 동작을 검증하지 못해 신뢰성이 낮아질 수 있음을 경험했습니다.
- Mock을 최소화하고 실제 객체를 사용하면 객체 간 협력을 검증하고 테스트 신뢰성을 높일 수 있었습니다. 하지만 테스트 데이터 관리와 실행 속도가 비효율적이었습니다
- 테스트의 신뢰성이 무엇보다 중요하다는 점에서, 고전파 방식이 비즈니스 로직 검증과 협력 테스트에 조금 더 적합하지 않을까 느끼게 되었습니다.

<details>
<summary>자세히</summary>

[test.md](content%2Ftest.md)

</details>
